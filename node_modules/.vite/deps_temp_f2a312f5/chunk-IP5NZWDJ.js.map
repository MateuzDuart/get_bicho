{
  "version": 3,
  "sources": ["../../@tauri-apps/api/core.js"],
  "sourcesContent": ["import { __classPrivateFieldGet, __classPrivateFieldSet } from './external/tslib/tslib.es6.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nvar _Channel_onmessage, _Channel_nextMessageId, _Channel_pendingMessages, _Resource_rid;\n/**\n * Invoke your custom commands.\n *\n * This package is also accessible with `window.__TAURI__.core` when [`app.withGlobalTauri`](https://v2.tauri.app/reference/config/#withglobaltauri) in `tauri.conf.json` is set to `true`.\n * @module\n */\n/**\n * Transforms a callback function to a string identifier that can be passed to the backend.\n * The backend uses the identifier to `eval()` the callback.\n *\n * @return A unique identifier associated with the callback function.\n *\n * @since 1.0.0\n */\nfunction transformCallback(callback, once = false) {\n    return window.__TAURI_INTERNALS__.transformCallback(callback, once);\n}\nclass Channel {\n    constructor() {\n        // @ts-expect-error field used by the IPC serializer\n        this.__TAURI_CHANNEL_MARKER__ = true;\n        _Channel_onmessage.set(this, () => {\n            // no-op\n        });\n        _Channel_nextMessageId.set(this, 0);\n        _Channel_pendingMessages.set(this, {});\n        this.id = transformCallback(({ message, id }) => {\n            // the id is used as a mechanism to preserve message order\n            if (id === __classPrivateFieldGet(this, _Channel_nextMessageId, \"f\")) {\n                __classPrivateFieldSet(this, _Channel_nextMessageId, id + 1, \"f\");\n                __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n                // process pending messages\n                const pendingMessageIds = Object.keys(__classPrivateFieldGet(this, _Channel_pendingMessages, \"f\"));\n                if (pendingMessageIds.length > 0) {\n                    let nextId = id + 1;\n                    for (const pendingId of pendingMessageIds.sort()) {\n                        // if we have the next message, process it\n                        if (parseInt(pendingId) === nextId) {\n                            // eslint-disable-next-line security/detect-object-injection\n                            const message = __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[pendingId];\n                            // eslint-disable-next-line security/detect-object-injection\n                            delete __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[pendingId];\n                            __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n                            // move the id counter to the next message to check\n                            nextId += 1;\n                        }\n                        else {\n                            // we do not have the next message, let's wait\n                            break;\n                        }\n                    }\n                    __classPrivateFieldSet(this, _Channel_nextMessageId, nextId, \"f\");\n                }\n            }\n            else {\n                __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[id.toString()] = message;\n            }\n        });\n    }\n    set onmessage(handler) {\n        __classPrivateFieldSet(this, _Channel_onmessage, handler, \"f\");\n    }\n    get onmessage() {\n        return __classPrivateFieldGet(this, _Channel_onmessage, \"f\");\n    }\n    toJSON() {\n        return `__CHANNEL__:${this.id}`;\n    }\n}\n_Channel_onmessage = new WeakMap(), _Channel_nextMessageId = new WeakMap(), _Channel_pendingMessages = new WeakMap();\nclass PluginListener {\n    constructor(plugin, event, channelId) {\n        this.plugin = plugin;\n        this.event = event;\n        this.channelId = channelId;\n    }\n    async unregister() {\n        return invoke(`plugin:${this.plugin}|remove_listener`, {\n            event: this.event,\n            channelId: this.channelId\n        });\n    }\n}\n/**\n * Adds a listener to a plugin event.\n *\n * @returns The listener object to stop listening to the events.\n *\n * @since 2.0.0\n */\nasync function addPluginListener(plugin, event, cb) {\n    const handler = new Channel();\n    handler.onmessage = cb;\n    return invoke(`plugin:${plugin}|registerListener`, { event, handler }).then(() => new PluginListener(plugin, event, handler.id));\n}\n/**\n * Get permission state for a plugin.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function checkPermissions(plugin) {\n    return invoke(`plugin:${plugin}|check_permissions`);\n}\n/**\n * Request permissions.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function requestPermissions(plugin) {\n    return invoke(`plugin:${plugin}|request_permissions`);\n}\n/**\n * Sends a message to the backend.\n * @example\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * await invoke('login', { user: 'tauri', password: 'poiwe3h4r5ip3yrhtew9ty' });\n * ```\n *\n * @param cmd The command name.\n * @param args The optional arguments to pass to the command.\n * @param options The request options.\n * @return A promise resolving or rejecting to the backend response.\n *\n * @since 1.0.0\n */\nasync function invoke(cmd, args = {}, options) {\n    return window.__TAURI_INTERNALS__.invoke(cmd, args, options);\n}\n/**\n * Convert a device file path to an URL that can be loaded by the webview.\n * Note that `asset:` and `http://asset.localhost` must be added to [`app.security.csp`](https://v2.tauri.app/reference/config/#csp-1) in `tauri.conf.json`.\n * Example CSP value: `\"csp\": \"default-src 'self' ipc: http://ipc.localhost; img-src 'self' asset: http://asset.localhost\"` to use the asset protocol on image sources.\n *\n * Additionally, `\"enable\" : \"true\"` must be added to [`app.security.assetProtocol`](https://v2.tauri.app/reference/config/#assetprotocolconfig)\n * in `tauri.conf.json` and its access scope must be defined on the `scope` array on the same `assetProtocol` object.\n *\n * @param  filePath The file path.\n * @param  protocol The protocol to use. Defaults to `asset`. You only need to set this when using a custom protocol.\n * @example\n * ```typescript\n * import { appDataDir, join } from '@tauri-apps/api/path';\n * import { convertFileSrc } from '@tauri-apps/api/core';\n * const appDataDirPath = await appDataDir();\n * const filePath = await join(appDataDirPath, 'assets/video.mp4');\n * const assetUrl = convertFileSrc(filePath);\n *\n * const video = document.getElementById('my-video');\n * const source = document.createElement('source');\n * source.type = 'video/mp4';\n * source.src = assetUrl;\n * video.appendChild(source);\n * video.load();\n * ```\n *\n * @return the URL that can be used as source on the webview.\n *\n * @since 1.0.0\n */\nfunction convertFileSrc(filePath, protocol = 'asset') {\n    return window.__TAURI_INTERNALS__.convertFileSrc(filePath, protocol);\n}\n/**\n * A rust-backed resource stored through `tauri::Manager::resources_table` API.\n *\n * The resource lives in the main process and does not exist\n * in the Javascript world, and thus will not be cleaned up automatiacally\n * except on application exit. If you want to clean it up early, call {@linkcode Resource.close}\n *\n * @example\n * ```typescript\n * import { Resource, invoke } from '@tauri-apps/api/core';\n * export class DatabaseHandle extends Resource {\n *   static async open(path: string): Promise<DatabaseHandle> {\n *     const rid: number = await invoke('open_db', { path });\n *     return new DatabaseHandle(rid);\n *   }\n *\n *   async execute(sql: string): Promise<void> {\n *     await invoke('execute_sql', { rid: this.rid, sql });\n *   }\n * }\n * ```\n */\nclass Resource {\n    get rid() {\n        return __classPrivateFieldGet(this, _Resource_rid, \"f\");\n    }\n    constructor(rid) {\n        _Resource_rid.set(this, void 0);\n        __classPrivateFieldSet(this, _Resource_rid, rid, \"f\");\n    }\n    /**\n     * Destroys and cleans up this resource from memory.\n     * **You should not call any method on this object anymore and should drop any reference to it.**\n     */\n    async close() {\n        return invoke('plugin:resources|close', {\n            rid: this.rid\n        });\n    }\n}\n_Resource_rid = new WeakMap();\nfunction isTauri() {\n    return 'isTauri' in window && !!window.isTauri;\n}\n\nexport { Channel, PluginListener, Resource, addPluginListener, checkPermissions, convertFileSrc, invoke, isTauri, requestPermissions, transformCallback };\n"],
  "mappings": ";AAKA,IAAI;AAAJ,IAAwB;AAAxB,IAAgD;AAAhD,IAA0E;AAe1E,SAAS,kBAAkB,UAAU,OAAO,OAAO;AAC/C,SAAO,OAAO,oBAAoB,kBAAkB,UAAU,IAAI;AACtE;AAqDA,qBAAqB,oBAAI,QAAQ,GAAG,yBAAyB,oBAAI,QAAQ,GAAG,2BAA2B,oBAAI,QAAQ;AAyDnH,eAAe,OAAO,KAAK,OAAO,CAAC,GAAG,SAAS;AAC3C,SAAO,OAAO,oBAAoB,OAAO,KAAK,MAAM,OAAO;AAC/D;AA0EA,gBAAgB,oBAAI,QAAQ;",
  "names": []
}
